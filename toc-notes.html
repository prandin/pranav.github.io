<html>
	<head>
	</head>
	<body>
		<h1>Course: Theory of Computation [Lecture Notes]</h1>

		<h2>Countability and Reducibility</h2>
		<p>
			<b>Countable Sets:</b> A set is said to be countable if all the elements of the set can
			be put in one-to-one correspondence with the set of natural numbers. It would somewhat be similar
			to giving an index to each element of the set, like key-value pairs. All finite sets are countable.
			<br>
			<b>Uncountable Sets:</b>A set that contains so many elements that they cannot be put in a one-to-one correspondence
			with the set of natural numbers.
			One way to think about this is that there is no way we could count all elements in these sets such that even if
			the counting goes on forever, we could reach a particular time in some finite time. Infinite sets can be countable
			or uncountable.

			<br><b>[Example 1]:</b>Consider the set of even numbers {2, 4, 6, ...}. If we map this set to the set of natural
			numbers {1, 2, 3, ...}, observe the mappings {1*2 = 2, 2*2 = 4, 3*2 = 6, ..., k*2 = 2k, (k+1)*2 = 2k + 2, ...}.
			Each subsequent element can be computed by taking a counting variable initialized to 1, which is doubled to
			obtain the corresponding value in the set. To obtain the next element of the set, simply
			increment by 1.
			<br><b>[Example 2]:</b>Consider the set of rational numbers. This set is actually
			countable. To prove so, we try establishing one-to-one correspondence in either
			dimensions of a table. To count the elements of the set, move to the next adjacent
			element (starting from the first element) and then move diagonally to reach the
			unvisited elements (in order).

			<h3>Properties of Countable Sets:</h3>
			<ul>

				<li><b>[Theorem]:</b>The subset of a countable set is countable. However, its power set is not countable.</li>
				<li><b>[Theorem]:</b>&Sigma;* is countable. However, 2<sup>&Sigma;*</sup> is not.</li>
				<li><b>[Theorem]:</b>The set of all TMs is countable. [<em>Every TM can be enocded as a sting of &Sigma; i.e. &Sigma;*</em>]</li>
				<li><b>[Corollary]:</b>Set of all languages generated by either Type 3, Type 2, Type 1, or Type 0 grammars are countable. [<em>Hint: Subset of a
				countable set is countable</em>]</li>
				<li>If <i>S<sub>1</sub></i> and <i>S<sub>2</sub></i> are two countable sets, then the following are also countable:
					<br><i>S<sub>1</sub></i>&cup;<i>S<sub>2</sub></i>,
					<br><i>S<sub>1</sub></i>&cap;<i>S<sub>2</sub></i>,
					<br><i>S<sub>1</sub></i>&times;<i>S<sub>2</sub></i>,
					<br><i>S<sub>1</sub></i>&minus;<i>S<sub>2</sub></i>
				</ul>	
			<p>
				While we do know that languages exist for which TMs cannot be constructed, it is difficult to given
			an example of such as of now. We still do not know if this is possible or not.
			</p>



		<div style="background-color:grey;">
			<b> Homework: </b>
			<p> <b>[Question 1]: </b> Show that the set of odd numbers {1, 3, 5, 7, ...} is a countable set.<br>
				<b>[Question 2]:</b>Is the language represented by the regular expression <i>a*b*</i> countable?<br>

			</p>



		</div>

		<h2>Undecidability - Hierarchy</h2>
		<p>For the purpose of understanding undecidability, let us assume three classes of languages:
			<ol>
				<li>Recursive Languages, </li>
				<li>Recursively Enumerable Languages, but not Recursive, and</li>
				<li>Recursively Enumerable Languages</li>
			</ol>
		Recursive languages are analogous to decidable languages.
		</p>
		<p>
			A language is semidecidable if and only if a TM can be constructed for the language i.e. the language is recursively enumerable. In other words, if a language is semidecidable, TMs are guaranteed to exist.
		</p>
		<p>Undecidable languages are those that are not decidable. No halting TMs exist for such languages, though TMs may exist.
			<ul>
				<li>We can say that if a language is not recursively enumerable, the language is definitely undecidable. But the converse need not be true. Non-recursive, recursively enumerable languages can also be undecidable.</li>
				<li>Some undecidable languages may be semidecidable</li>
			</ul>
		<p>RECURSIVE LANGUAGES: Completely decidable and semidecidable
		<br>NON-RECURSIVE, RECURSIVELY ENUMERABLE LANGUAGES: Can be semidecidable or undecidable
		<br>NOT RECURSIVELY ENUMERABLE LANGUAGES: Completely undecidable
		<br>The above points become obvious since TMs can be constructed for the first two cases (halting TMs for the first, while general TMs for the second), but not the third.
		</p>

		<h3>Automata</h3>
		<ul>
			<li>For FAs, almost all properties are decidable</li>
			<li>For PDAs, some properties are decidable</li>
			<li>For TMs, almost all properties are undecidable</li>
		</ul>

		<h3>Decision Properties for FAs/ RLs</h3>
		<p>Some of the decision properties we will review are:
			<ol>
				<li>Emptiness: Remove all unreachable states from start state. If the resulting FA has at least one final state, then
				the language of the FA is non-empty. Otherwise, it is empty.</li>
				<li>Finiteness: Remove all unreachable states from start state and dead states (states from which a final state is unreachable). If the
				resulting FA is free from cycles and loops, the language of the FA is finite. Otherwise, it is infinte.</li>
				<li>Membership: If the transition path for complete input string w from start state ends at a final state, then w is in the language.
				Note that membership can only be decided after the entire string has been read.</li>
				<li>Equivalence of FAs: Two FAs M1, M2 are said to be equivalent if and only if both have the same language.
				Both M1 and M2 need not have the same number of states. However, if they do, then they are
			said to be isomorphic.
		<br>
				To test for equivalency, construct a transition table that contains pair of states (s, t) such that s is in M1 and t is in M2.
				For each input symbol, if we obtain pairs of the form (F, NF), or (NF, F), then we can declare that the two machines are not equivalent.
				Otherwise, keep constructing the tables until no further pairs are possible. If all the states are of (F, F), or (NF, NF), then the
				machines are equivalent.
	 			</li>
				<li>Totality of Universality: Does the FA accept language &Sigma;*?
				To test, convert the given FA to minimal FA. If it represents the minimal FA for &Sigma;*, then we can say
			that the FA satisfies totality.</li>
				<li>Disjointness: Take the cross product of two machines to create new FA. If this new FA contains any final
				state, then the languages of the two FAs are not disjoint. Otherwise, they are disjoint.</li>
				<li>Set Containment: To check if a language is a subset of another, simply take the intersection of one of them and the complement of other. If it is empty,
				then the first language is contained within the second. Otherwise, it is not contained. </li>
				<li>Ambiguity</li>
				<li>Regularity</li>
				<li>Halting Problem</li>

			</ol>
			Refer the Decidability Table to know the decidable problems of each type of language.
		</p>

		<div style="background-color:grey;">
			<b> Homework: </b>
			<p> <b>[Question 1]: </b> Consider two FAs A and B that accepts the languages given below:
				<br>A: (a + b)*
				<br>B: (a + b)*b
				<br>Are the two FAs equivalent?
			</p>



		</div>


		<footer>
		 <p>Author: Pranav D.</p>
		 <p><a href="https://www.pranavd.ml/">Home</a></p>
		</footer>
	</body>


</html>
