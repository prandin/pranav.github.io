<html>
	<head>
	</head>

	<body>
		<h1>Course: Theory of Computation [Lecture Notes]</h1>
		<h2>Undecidability - Hierarchy</h2>
		<p>For the purpose of understanding undecidability, let us assume three classes of languages:
			<ol>
				<li>Recursive Languages, </li>
				<li>Recursively Enumerable Languages, but not Recursive, and</li>
				<li>Recursively Enumerable Languages</li>
			</ol>
		Recursive languages are analogous to decidable languages.
		</p>
		<p>
			A language is semidecidable if and only if a TM can be constructed for the language i.e. the language is recursively enumerable. In other words, if a language is semidecidable, TMs are guaranteed to exist.
		</p>
		<p>Undecidable languages are those that are not decidable. No halting TMs exist for such languages, though TMs may exist.
			<ul>
				<li>We can say that if a language is not recursively enumerable, the language is definitely undecidable. But the converse need not be true. Non-recursive, recursively enumerable languages can also be undecidable.</li>
				<li>Some undecidable languages may be semidecidable</li>
			</ul>
		<p>RECURSIVE LANGUAGES: Completely decidable and semidecidable
		<br>NON-RECURSIVE, RECURSIVELY ENUMERABLE LANGUAGES: Can be semidecidable or undecidable
		<br>NOT RECURSIVELY ENUMERABLE LANGUAGES: Completely undecidable
		<br>The above points become obvious since TMs can be constructed for the first two cases (halting TMs for the first, while general TMs for the second), but not the third.
		</p>
		<h3>Automata</h3>
		<ul>
			<li>For FAs, almost all properties are decidable</li>
			<li>For PDAs, some properties are decidable</li>
			<li>For TMs, almost all properties are undecidable</li>
		</ul>

		<h3>Decision Properties for FAs/ RLs</h3>
		<p>Some of the decision properties we will review are:
			<ol>
				<li>Emptiness: Remove all unreachable states from start state. If the resulting FA has at least one final state, then
				the language of the FA is non-empty. Otherwise, it is empty.</li>
				<li>Finiteness: Remove all unreachable states from start state and dead states (states from which a final state is unreachable). If the
				resulting FA is free from cycles and loops, the language of the FA is finite. Otherwise, it is infinte.</li>
				<li>Membership: If the transition path for complete input string w from start state ends at a final state, then w is in the language.
				Note that membership can only be decided after the entire string has been read.</li>
				<li>Equivalence of FAs: Two FAs M1, M2 are said to be equivalent if and only if both have the same language.
				Both M1 and M2 need not have the same number of states. However, if they do, then they are
			said to be isomorphic.
		<br>
				To test for equivalency, construct a transition table that contains pair of states (s, t) such that s is in M1 and t is in M2.
				For each input symbol, if we obtain pairs of the form (F, NF), or (NF, F), then we can declare that the two machines are not equivalent.
				Otherwise, keep constructing the tables until no further pairs are possible. If all the states are of (F, F), or (NF, NF), then the
				machines are equivalent.
	 			</li>
				<li>Totality of Universality: Does the FA accept language &Sigma*?
				To test, convert the given FA to minimal FA. If it represents the minimal FA for &Sigma*, then we can say
			that the FA satisfies totality.</li>
				<li>Disjointness: Take the cross product of two machines to create new FA. If this new FA contains any final
				state, then the languages of the two FAs are not disjoint. Otherwise, they are disjoint.</li>
				<li>Set Containment</li>
				<li>Ambiguity</li>
				<li>Regularity</li>
				<li>Halting Problem</li>

			</ol>
		</p>

		<div style="background-color:grey;">
			<b> Homework: </b>
			<p> <b>[Question 1]: </b> Consider two FAs A and B that accepts the languages given below:
				<br>A: (a + b)*
				<br>B: (a + b)*b
				<br>Are the two FAs equivalent?
			</p>



		</div>


		<footer>
		 <p>Author: Pranav D.</p>
		 <p><a href="https://www.pranavd.ml/">Home</a></p>
		</footer>
	</body>


</html>
